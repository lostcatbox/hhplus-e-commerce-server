# STEP 19: 부하 테스트 계획서

## 1. 테스트 개요

### 1.1 목적
- OrderFacade.processOrder() 메서드를 통한 주문 처리 API의 성능 검증
- 동시 주문 처리 시 발생할 수 있는 병목 지점 식별
- 예상 트래픽 하에서의 시스템 안정성 검증
- 데이터베이스 동시성 제어 메커니즘의 효과성 검증

### 1.2 테스트 대상
- **API**: `POST /v1/orders`
- **주요 기능**: 주문 접수 → 상품 재고 차감 → 결제 처리 → 주문 완료
- **비즈니스 로직**: OrderFacade.processOrder()

### 1.3 테스트 환경
- **애플리케이션**: Spring Boot (Kotlin)
- **데이터베이스**: MySQL with JPA/Hibernate
- **동시성 제어**: Pessimistic Lock, @Transactional
- **메시징**: Kafka (주문 완료 이벤트)

## 2. 예상 병목 지점 분석

### 2.1 데이터베이스 레벨
- **재고 차감 로직**: 동일 상품에 대한 동시 주문 시 락 경합
- **주문 생성**: order, order_lines 테이블 INSERT 성능
- **주문 히스토리**: 상태 변경 시마다 order_history INSERT

### 2.2 애플리케이션 레벨
- **트랜잭션 범위**: 전체 주문 처리 과정이 하나의 트랜잭션
- **외부 의존성**: 결제 서비스, 쿠폰 서비스
- **이벤트 발행**: Kafka 메시지 발송

### 2.3 예상 문제점
- **데드락 발생 가능성**: 여러 상품 동시 주문 시
- **커넥션 풀 고갈**: 긴 트랜잭션으로 인한 DB 커넥션 점유
- **재고 부족 예외**: 동시 주문량이 재고를 초과하는 경우

## 3. 테스트 시나리오 설계

### 3.1 Load Test (부하 테스트)
- **목표 TPS**: 50 TPS
- **지속 시간**: 5분
- **가상 사용자**: 100명
- **시나리오**: 정상적인 쇼핑 패턴 모방

### 3.2 Stress Test (스트레스 테스트)
- **목표**: 시스템 한계점 찾기
- **부하 증가 패턴**: 10 TPS → 100 TPS (10분간 점진적 증가)
- **가상 사용자**: 200명
- **시나리오**: 급격한 트래픽 증가 상황

### 3.3 Peak Test (최고 부하 테스트)
- **목표**: 이벤트성 트래픽 대응 능력 검증
- **순간 TPS**: 200 TPS
- **지속 시간**: 30초
- **시나리오**: 한정 상품 오픈, 플래시 세일 상황

### 3.4 동시성 테스트
- **목표**: 동일 상품 대량 주문 시 재고 정합성 검증
- **테스트 케이스**: 재고 10개 상품에 대해 100명이 동시 주문
- **예상 결과**: 정확히 10개만 주문 성공, 90개 실패

## 4. 테스트 데이터 준비

### 4.1 기본 테스트 데이터
```sql
-- 사용자 데이터 (1000명)
INSERT INTO users (id, name, email) VALUES ...

-- 상품 데이터 (100개)
INSERT INTO products (id, name, price, stock) VALUES 
  (1, '인기상품A', 10000, 1000),
  (2, '인기상품B', 15000, 500),
  (3, '한정상품C', 20000, 10),
  ...

-- 포인트 데이터 (사용자별 100만원)
INSERT INTO points (user_id, amount) VALUES ...
```

### 4.2 랜덤 데이터 생성 전략
- **사용자 ID**: 1~1000 범위에서 랜덤 선택
- **상품 ID**: 1~100 범위에서 1-3개 랜덤 선택
- **주문 수량**: 1~5개 범위에서 랜덤 선택
- **쿠폰 사용**: 30% 확률로 쿠폰 적용

## 5. 성능 목표 지표

### 5.1 응답 시간 목표
- **평균 응답 시간**: 500ms 이하
- **95th Percentile**: 1초 이하
- **99th Percentile**: 2초 이하
- **최대 응답 시간**: 5초 이하

### 5.2 처리량 목표
- **정상 트래픽**: 50 TPS 처리 가능
- **피크 트래픽**: 100 TPS 처리 가능
- **에러율**: 1% 이하 (재고 부족 제외)

### 5.3 시스템 리소스 목표
- **CPU 사용률**: 80% 이하
- **메모리 사용률**: 70% 이하
- **DB 커넥션 풀**: 80% 이하

## 6. 측정 지표

### 6.1 성능 지표
- **TPS (Transaction Per Second)**
- **Response Time (평균, 중간값, 95th, 99th percentile)**
- **Error Rate (%)**
- **Throughput (requests/sec)**

### 6.2 시스템 지표
- **CPU, Memory, Disk 사용률**
- **DB Connection Pool 사용률**
- **Query 실행 시간**
- **Lock Wait Time**

### 6.3 비즈니스 지표
- **주문 성공률**
- **재고 정합성**
- **데이터 일관성**

## 7. 테스트 도구 선정

### 7.1 선택: k6
- **장점**: JavaScript 기반으로 스크립트 작성 용이
- **성능**: Go 언어로 구현되어 높은 성능
- **기능**: HTTP/2, WebSocket, gRPC 지원
- **확장성**: 클라우드 환경에서 분산 테스트 가능

### 7.2 대안 도구들
- **JMeter**: GUI 제공, 다양한 프로토콜 지원
- **Artillery**: Node.js 기반, 클라우드 네이티브
- **nGrinder**: 네이버 개발, 웹 UI 제공

## 8. 예상 장애 시나리오

### 8.1 데이터베이스 관련
- **데드락 발생**: 다중 상품 주문 시 테이블 락 순서 불일치
- **커넥션 풀 고갈**: 장기간 실행되는 트랜잭션
- **Slow Query**: 복잡한 JOIN 쿼리나 인덱스 부재

### 8.2 애플리케이션 관련
- **메모리 누수**: 대량 요청 처리 시 객체 생성
- **OOM Error**: 힙 메모리 부족
- **Thread Pool 고갈**: 동시 요청 처리 한계

### 8.3 외부 연동 관련
- **Kafka 지연**: 메시지 발송 실패나 지연
- **결제 서비스 타임아웃**: 외부 API 응답 지연

## 9. 테스트 수행 계획

### 9.1 1단계: 기능 검증 (30분)
- 단일 요청 정상 처리 확인
- 기본 에러 케이스 확인
- 테스트 데이터 검증

### 9.2 2단계: Load Test (1시간)
- 목표 TPS로 안정적 처리 확인
- 성능 지표 수집
- 리소스 모니터링

### 9.3 3단계: Stress Test (1시간)
- 점진적 부하 증가
- 시스템 한계점 파악
- 복구 능력 확인

### 9.4 4단계: Peak Test (30분)
- 순간 고부하 처리 능력 확인
- 급격한 트래픽 증가 대응

### 9.5 5단계: 동시성 Test (30분)
- 재고 정합성 검증
- 데이터 일관성 확인

## 10. 결과 분석 및 개선 방향

### 10.1 분석 항목
- 목표 지표 달성 여부
- 병목 지점 식별
- 에러 원인 분석
- 리소스 사용 패턴

### 10.2 예상 개선 방향
- **인덱스 최적화**: 쿼리 성능 개선
- **커넥션 풀 튜닝**: 적정 크기 설정
- **캐싱 도입**: 자주 조회되는 데이터
- **비동기 처리**: 이벤트 발행 등

### 10.3 모니터링 개선
- **실시간 대시보드**: Grafana 설정
- **알림 설정**: 임계치 초과 시 Slack 알림
- **로그 분석**: 에러 패턴 분석 