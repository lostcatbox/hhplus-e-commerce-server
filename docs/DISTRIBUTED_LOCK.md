# Redis 기반 분산락(Distributed Lock) 구현 및 사용 가이드

## 개요

동시성 이슈는 여러 서버 인스턴스 또는 다중 스레드 환경에서 동일한 리소스에 동시에 접근할 때 발생합니다. DB 트랜잭션만으로는 분산 환경에서의 동시성 문제를 완벽하게 해결할 수 없으므로, Redis를 활용한 분산락 패턴을 구현했습니다.

## 분산락이 필요한 이유

1. **DB 트랜잭션의 한계**: DB 트랜잭션만으로는 DB 접근 이전 단계의 로직 실행을 제어할 수 없습니다.
2. **서버 부하 감소**: 불필요한 DB 접근을 사전에 차단하여 DB 부하를 줄일 수 있습니다.
3. **분산 환경 지원**: 여러 서버 인스턴스가 동일한 리소스에 접근할 때도 일관성을 보장합니다.

## 구현 방식

### 핵심 구성 요소

1. `@DistributedLock` 애노테이션: 분산락을 적용할 메서드에 선언
2. `DistributedLockAspect`: 애노테이션이 적용된 메서드 호출을 인터셉트하여 분산락 로직 적용
3. Redis를 사용한 Lock 관리: Redisson 클라이언트를 통해 Redis 기반 분산락 구현

### 동작 원리

1. 메서드 호출 시 AOP에 의해 인터셉트됨
2. Redis에 지정된 키로 락 획득 시도
3. 락 획득 성공 시 메서드 실행
4. 락 획득 실패 시 예외 발생
5. 메서드 실행 완료 후 락 해제

## 적용 방법

### 1. 애노테이션 적용

```kotlin
@DistributedLock(key = "point_charge_#{userId}")
@Transactional
fun chargePoint(userId: Long, chargeAmount: Long): Point {
    val point = pointRepository.findByUserId(userId) ?: Point.EMPTY(userId)
    val updatedPoint = point.chargePoint(chargeAmount)
    return pointRepository.save(updatedPoint)
}
```

### 2. 주요 파라미터 설명

- **key**: 락의 이름을 정의합니다. 파라미터 치환을 지원합니다.
  - 예: `"user_#{userId}"` 또는 `"order_#{orderId}"`
  - `#{파라미터명}` 형식으로 메서드 파라미터를 키에 포함시킬 수 있습니다.
- **waitTime**: 락 획득 대기 시간 (밀리초, 기본값: 5000)
- **leaseTime**: 락 유지 시간 (밀리초, 기본값: 10000)
- **timeUnit**: 시간 단위 (기본값: TimeUnit.MILLISECONDS)

## 분산락 적용 모범 사례

### 1. 적절한 락 키 선택

- 너무 넓은 범위의 키는 불필요한 경합을 발생시킵니다.
- 너무 좁은 범위의 키는 동시성 보호가 부족할 수 있습니다.
- 리소스 특성에 맞는 키를 선택하세요. (예: `point_user_#{userId}`)

### 2. 트랜잭션과 락의 순서

- ✅ **올바른 방법**: 분산락 획득 → 트랜잭션 시작 → 비즈니스 로직 수행 → 트랜잭션 종료 → 락 해제
- ❌ **잘못된 방법**: 트랜잭션 시작 → 분산락 획득 → 비즈니스 로직 수행 → 락 해제 → 트랜잭션 종료

### 3. 락 타임아웃 설정

- 락 획득 대기 시간(waitTime)은 사용자 경험을 고려하여 설정하세요.
- 락 유지 시간(leaseTime)은 비즈니스 로직 실행 시간보다 충분히 길게 설정하세요.

## 주의사항

1. **데드락 방지**: leaseTime 설정을 통해 무한정 락이 유지되는 것을 방지하세요.
2. **성능 영향**: 불필요한 락 적용은 성능 저하를 가져올 수 있습니다.
3. **예외 처리**: 락 획득 실패 시 발생하는 `LockAcquisitionFailedException`을 적절히 처리하세요.
4. **트랜잭션 경계**: 트랜잭션 경계와 락 획득/해제 순서에 주의하세요.
5. **파라미터 표현식**: 파라미터 치환을 위해 `#{파라미터명}` 형식을 사용하세요.

## 테스트

분산락의 효과를 검증하기 위한 통합 테스트를 작성했습니다. 테스트 시나리오는 다음과 같습니다:

1. 동시에 여러 스레드에서 포인트 차감
2. 동시에 충전과 사용 요청

테스트 코드는 `PointDistributedLockTest` 클래스를 참조하세요. 